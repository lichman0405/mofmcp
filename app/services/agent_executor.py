# app/services/agent_executor.py
# This module contains the AgentExecutor class, which is responsible for
# parsing and executing a plan generated by the LLM planner.
# Author: Shibo Li
# Date: 2025-06-18
# Version: 0.1.0

import json
from typing import Dict, Any, List

from app.core.logger import console
from app.services.tools.converter_tool import ConverterTool
from app.services.tools.maceopt_tool import MaceoptTool
from app.services.tools.xtb_tool import XTBTool
from app.services.tools.zeo_tool import ZeoTool

class AgentExecutor:
    """
    Parses a plan from the LLM and executes the specified tools in sequence.
    Manages the state and data flow between steps.
    """
    def __init__(self, task_id: str):
        self.task_id = task_id
        # context stores the execution results of each step, serving as the short-term memory of the agent
        self.context: Dict[str, Any] = {}
        
        # Register all available tools
        self._register_tools()

    def _register_tools(self):
        """Initializes all tool classes and maps them to their names."""
        zeo_tool_instance = ZeoTool() # ZeoTool methods are stateless, so a single instance can be shared
        
        self.tools = {
            "convert_structure_file": ConverterTool(self.task_id).execute,
            "optimize_structure_with_mace": MaceoptTool(self.task_id).execute,
            "optimize_structure_with_xtb": XTBTool(self.task_id).execute,
            "calculate_pore_diameter": zeo_tool_instance.calculate_pore_diameter,
            "calculate_surface_area": zeo_tool_instance.calculate_surface_area,
            "calculate_accessible_volume": zeo_tool_instance.calculate_accessible_volume,
            "calculate_probe_volume": zeo_tool_instance.calculate_probe_volume,
            "analyze_channels": zeo_tool_instance.analyze_channels,
        }
        console.info(f"[AgentExecutor] Registered tools: {list(self.tools.keys())}")

    def _resolve_parameters(self, params: dict) -> dict:
        """
        Resolves the parameters of a step. If a parameter is a reference, it is replaced with the actual value from the context.
        """
        resolved_params = {}
        for key, value in params.items():
            if isinstance(value, str) and value.startswith("{{") and value.endswith("}}"):
                # Reference format: {{steps.step_1.output.optimized_file_path}}
                try:
                    ref_parts = value.strip('{}').split('.')
                    # ref_parts will be ['steps', 'step_1', 'output', 'optimized_file_path']
                    step_name_ref = ref_parts[1]  # e.g., "step_1"
                    output_key = ref_parts[3]     # e.g., "optimized_file_path"
                    
                    resolved_value = self.context.get(step_name_ref, {}).get("output", {}).get(output_key)
                    
                    if resolved_value is None:
                        raise ValueError(f"Could not resolve reference '{value}'. Key '{output_key}' not found in output of '{step_name_ref}'. Context: {self.context}")
                    
                    resolved_params[key] = resolved_value
                except (IndexError, ValueError) as e:
                    raise ValueError(f"Invalid reference format or unresolved value: {value}. Error: {e}")
            else:
                resolved_params[key] = value
        return resolved_params

    def execute_plan(self, plan: Dict[str, List[Dict]], initial_context: Dict) -> Dict[str, Any]:
        """
        Executes a plan generated by the LLM planner.

        Args:
            plan: A dictionary containing a "plan" key and a list of steps.
            initial_context: A dictionary containing initial information, such as the path of files uploaded by the user.

        Returns:
            The final context containing the results of all steps.
        """
        console.rule(f"[AgentExecutor] Starting Plan Execution for Task {self.task_id}", style="bold magenta")
        self.context = initial_context
        
        if "plan" not in plan or not isinstance(plan["plan"], list):
            error_msg = "Invalid plan format: Must be a dict with a 'plan' key containing a list of steps."
            console.error(f"[AgentExecutor] {error_msg}")
            self.context["final_status"] = {"status": "error", "message": error_msg}
            return self.context

        sorted_plan = sorted(plan["plan"], key=lambda s: s.get("step_number", float('inf')))

        for step in sorted_plan:
            step_num = step.get("step_number")
            tool_name = step.get("tool_name")
            description = step.get("description", "No description.")
            parameters = step.get("parameters", {})
            step_name_in_context = f"step_{step_num}"

            console.info(f"Executing Step {step_num}: {description} (Tool: '{tool_name}')")

            if tool_name not in self.tools:
                error_msg = f"Tool '{tool_name}' not found in registered tools."
                console.error(f"[AgentExecutor] {error_msg}")
                self.context[step_name_in_context] = {"status": "error", "message": error_msg}
                break 

            try:
                resolved_params = self._resolve_parameters(parameters)
                console.info(f"Resolved parameters: {json.dumps(resolved_params, indent=2)}")

                tool_function = self.tools[tool_name]
                result = tool_function(tool_input=resolved_params)
                
                self.context[step_name_in_context] = {"tool_name": tool_name, "status": "success", "output": result}
                console.success(f"Step {step_num} executed successfully.")

                # If tool execution fails, terminate the entire plan
                if result.get("status") != "success":
                    console.error(f"Tool '{tool_name}' reported failure in step {step_num}. Stopping plan execution.")
                    break
            
            except Exception as e:
                console.exception(f"Critical error executing tool '{tool_name}' in step {step_num}")
                self.context[step_name_in_context] = {"tool_name": tool_name, "status": "error", "message": str(e)}
                break

        console.rule("[AgentExecutor] Plan Execution Finished", style="bold magenta")
        self.context["final_status"] = {"status": "completed"}
        return self.context