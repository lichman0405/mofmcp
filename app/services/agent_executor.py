# app/services/agent_executor.py
# This module contains the AgentExecutor class, which is responsible for
# parsing and executing a plan generated by the LLM planner.
# This final version includes enhanced logging and correct final status reporting.
# Author: Shibo Li
# Date: 2025-06-22
# Version: 1.1.0

import json
from typing import Dict, Any, List

from app.core.logger import console
from app.services.tools.maceopt_tool import MaceoptTool
from app.services.tools.dftb_tool import DFTBTool
from app.services.tools.zeo_tool import ZeoTool

class AgentExecutor:
    """
    Parses a plan from the LLM and executes the specified tools in sequence.
    Manages the state and data flow between steps.
    """
    def __init__(self, task_id: str):
        self.task_id = task_id
        # save short-term memory context
        self.context: Dict[str, Any] = {}
        
        # 
        self._register_tools()
        console.info(f"[AgentExecutor] Initialized for Task {self.task_id}")
        console.info(f"[AgentExecutor] Available tools: {list(self.tools.keys())}")

    def _register_tools(self):
        """Initializes all tool classes and maps them to their names."""
        zeo_tool_instance = ZeoTool()
        
        self.tools = {
            "optimize_structure_with_mace": MaceoptTool(self.task_id).execute,
            "optimize_structure_with_dftb_xtb": DFTBTool(self.task_id).execute,
            
            "calculate_pore_diameter": zeo_tool_instance.calculate_pore_diameter,
            "calculate_surface_area": zeo_tool_instance.calculate_surface_area,
            "calculate_accessible_volume": zeo_tool_instance.calculate_accessible_volume,
            "calculate_probe_volume": zeo_tool_instance.calculate_probe_volume,
            "analyze_channels": zeo_tool_instance.analyze_channels,
        }
        console.info(f"[AgentExecutor] Registered tools: {list(self.tools.keys())}")

    def _resolve_parameters(self, params: dict) -> dict:
        """
        parse and resolve parameters, replacing references like
        {{steps.step_1.output.output_file_path}} with actual values from the context.
        """
        resolved_params = {}
        for key, value in params.items():
            if isinstance(value, str) and value.startswith("{{") and value.endswith("}}"):
                try:
                    ref_parts = value.strip('{}').split('.')
                    step_name_ref = ref_parts[1]
                    output_key = ref_parts[-1]
                    
                    # Safely navigate the context dictionary
                    resolved_value = self.context.get(step_name_ref, {}).get("output", {}).get(output_key)
                    
                    if resolved_value is None:
                        raise ValueError(f"Could not resolve reference '{value}'. Key '{output_key}' not found in output of '{step_name_ref}'. Context: {self.context}")
                    
                    resolved_params[key] = resolved_value
                except (IndexError, ValueError) as e:
                    raise ValueError(f"Invalid reference format or unresolved value: {value}. Error: {e}")
            else:
                resolved_params[key] = value
        return resolved_params

    def execute_plan(self, plan: Dict[str, List[Dict]], initial_context: Dict) -> Dict[str, Any]:
        """
        Executes the provided plan step by step, updating the context with results.
        """
        console.rule(f"[AgentExecutor] Starting Plan Execution for Task {self.task_id}", style="bold magenta")
        self.context = initial_context
        
        if "plan" not in plan or not isinstance(plan["plan"], list):
            error_msg = "Invalid plan format: Must be a dict with a 'plan' key containing a list of steps."
            console.error(f"[AgentExecutor] {error_msg}")
            self.context["final_status"] = {"status": "error", "message": error_msg}
            return self.context

        sorted_plan = sorted(plan["plan"], key=lambda s: s.get("step_number", float('inf')))
        
        #  Initialize a flag to track the success of the plan execution
        plan_succeeded = True

        for step in sorted_plan:
            step_num = step.get("step_number")
            tool_name = step.get("tool_name")
            description = step.get("description", "No description provided by LLM.")
            parameters = step.get("parameters", {})
            step_name_in_context = f"step_{step_num}"

            console.info(f"Executing Step {step_num}: {description} (Tool: '{tool_name}')")

            try:
                resolved_params = self._resolve_parameters(parameters)
                console.info(f"Resolved parameters: {json.dumps(resolved_params, indent=2)}")

                if tool_name is None or not isinstance(tool_name, str):
                    raise ValueError(f"Tool name is invalid: {tool_name}")

                tool_function = self.tools[tool_name]
                result = tool_function(tool_input=resolved_params)
                
                self.context[step_name_in_context] = {
                    "tool_name": tool_name, 
                    "status": "success",
                    "parameters_used": resolved_params, 
                    "output": result
                }
                
                if result.get("status") != "success":
                    console.error(f"Tool '{tool_name}' reported failure in step {step_num}. Stopping plan execution.")
                    plan_succeeded = False 
                    break
            
            except Exception as e:
                console.exception(f"Critical error executing tool '{tool_name}' in step {step_num}")
                self.context[step_name_in_context] = {"tool_name": tool_name, "status": "error", "message": str(e)}
                plan_succeeded = False
                break

        console.rule("[AgentExecutor] Plan Execution Finished", style="bold magenta")
        

        if plan_succeeded:
            self.context["final_status"] = {"status": "completed"}
            console.success(f"Task {self.task_id} marked as COMPLETED.")
        else:
            self.context["final_status"] = {"status": "failed"}
            console.error(f"Task {self.task_id} marked as FAILED due to an error in one of the steps.")

        return self.context
